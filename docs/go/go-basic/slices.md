# Go 切片

## 数据结构

切片(slice)是在数组(array)之上的抽象数据类型，数组的长度是固定的，长度是数组类型的一部分。可以把切片看作动态数组，它是具有三个字段的数据结构，这些字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。

因此，可以铜鼓`len`和`cap`获取切片的长度和容量。

## 初始化

Go 语言提供了四种初始化切片的方式：

1. 使用 `make`指定类型、长度以及可选的容量

    ```go
    x := make([]int, 5)
    ```

2. 通过字面量初始化切片

    ```go
    data := []int{}
    ```

3. 从数组或者切片派生切片

    ```go
    x := [4]int{5,6,7,8}
    y := x[:]
    c := []int{1,2,3,4}
    d := x[:]
    //完全派生表达式包含第三部分，该部分定义父切片容量中的最后位置，用来确定子切片可以使用的容量，
    //将其减去起始偏移量就能得到子切片的实际容量。
    d := x[:2:2]
    ```

    !> 派生切片会共享内存，因此要避免修改派生切片或者使用完全派生表达式避免使用`append`造成的切片共享问题。

## 扩容

`append` 函数接受至少两个参数，一个为任意类型的切片，一个为该类型的值。`append()` 函数会改变参数的底层数组，并返回一个新的切片。因此，返回切片通常被赋值给原切片，以避免潜在的内存共享导致的错误。

```go
var x []int
x = append(x, 10)
```

`append` 函数支持可变参数，因此可以使用展开运算符添加另一个切片。

```go
y := []int{20,30,40}
x = append(x, y)
```

## 拷贝

`copy` 操作会从源切片拷贝尽可能多的数据到目标切片，然后返回拷贝的元素数量，其限制仅仅在哪个切片的容量更小。因此，切片的容量不重要，长度至关重要。

```go
// num := copy(target, source)
x :+ []int{1,2,3,4}
y := make([]int, 4)
num := copy(y, x)
```
